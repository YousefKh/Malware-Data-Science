# import the requisite modules
from sklearn import tree
from sklearn.feature_extraction import DictVectorizer

# Initializing the decision tree classifier and vectorizer

classifier = tree.DecisionTreeClassifier() # using sklearn's default decision tree settings

vectorizer = DictVectorizer(sparse=False) # turn sparse vectors feature off

# Declaring training and label vectors
training_examples = [
        {'packed':1, 'contains_encrypted':0},
        {'packed':0, 'contains_encrypted':0},
        {'packed':1, 'contains_encrypted':1},
        {'packed':1, 'contains_encrypted':0},
        {'packed':0, 'contains_encrypted':1},
        {'packed':1, 'contains_encrypted':0},
        {'packed':0, 'contains_encrypted':0},
        {'packed':0, 'contains_encrypted':0},
        ]
ground_truth = [1,1,1,1,0,0,0,0]

# initialize the vectroizer with the training data 
vectorizer.fit(training_examples)

# transform the training examples to vector form
X = vectorizer.transform(training_examples)
y = ground_truth # call ground truth 'y', by convention

# Train the detector (a.k.a. 'fit' the classifier)
classifier.fit(X,y)

# Determining whether a binary is malicious
test_ex = {'packed': 1, 'contains_encrypted':0}
test_vec = vectorizer.transform(test_ex)
print classifier.predict(test_vec)

# Visualizing The Decision Tree
with open("classifier.dot", "w") as output_file:
    tree.export_graphviz(
            classifier,
            feature_names = vectorizer.get_feature_names(),
            out_file = output_file)
import os
os.system("dot classifier.dot -Tpng -o classifier.png")
