# !/usr/bin/python

# required Libs
import argparse
import os
import networkx
from networkx.drawing.nx_pydot import write_dot

# Function to compute the jaccard index
def jaccard(set1, set2):
    # Compute the jaccard distance between two sets by taking their intersection,
    # union and then dividing the numbr of elements  in the intersection by the number of element in their union.
    intersection = set1.intersection(set2)
    intersection_length = float(len(intersection))
    union = set1.union(set2)
    union_length = float(len(union))
    return intersection_length / union_length

# Extract Strings from binary indicated by  'fullpath' parameter, and then return the set of unique strings in the binary.
def getstrings(fullpath):
    strings = os.popen("strings '{0}'".format(fullpath)).read()
    srtings = set(strings.split("\n"))
    return strings

# Do a cursory sanity check to make sure 'fullpath' is a windows PE exe (exe start with 'MZ')
def pecheck(fullpath):
    return open(fullpath).read(2) == "MZ"

# Parse the user's command line arguments
if __name__ == '__main__':
     parser = argparse.ArgumentParser(description = "Identify similarities between malware samples and build similarity graph")
     parser.add_argument("target_directory", help= "Directory containing malware")
     parser.add_argument("out_dot_file", help= "Where to save the output graph DOT file")
     parser.add_argument("--jaccard_index_threshold", "-j", dest= "threshold", type= float, default= 0.8, help= "Threshold above which to create an 'edge', between samples")
     args = parser.parse_args()


# extracting features from PE files in the target directory and initializing the shared code network
malware_paths = [] # Where we'll store the malware file paths
malware_features = dict() # Where we'll store the malware strings 
graph = networkx.Graph() # The Similarity graph
for root, dirs, paths in os.walk(args.target_directory):
    # Walk the target directory tree and store all of the file paths
    for path in paths:
        full_path = os.path.join(root, path)
        malware_paths.append(full_path)
# Filter out any paths that aren't PE files
malware_paths = filter(pecheck, malware_paths)
# get and store the strings for all of the malware PE files
for path in malware_path:
    features = getstrings(path)
    print "Extracted {0} features from {1} ...".format(len(features), path)
    malware_features[path] = features
    # add each malware file to the graph
    graph.add_node(path, label = os.path.split(path)[-1][:10])


# Iterate through all pairs of malware
for malware0, malware1 in itertools.combinations(malware_paths, 2):
    # Compute the jaccard distance for the current pair
    jaccard_index = jaccard(malware_features[malware0], malware_features[malware1])
    # if the jaccard distance is above the threshold, add an edge
    if jaccard_index > args.thershold:
        print malware0, malware1, jaccard_index
        graph.add_edge(malware0, malware1, penwidth= 1+(jaccard_index-args.threshold)*10)
        
        # Write the graph to disk so we can visualize it 
        write_dot(graph, args.output_dot_file)

